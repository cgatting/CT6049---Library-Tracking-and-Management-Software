\documentclass[12pt,a4paper]{article}

% Essential packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{url}
\usepackage{hyperref}
\usepackage{cite}
\usepackage{setspace}
\usepackage{enumitem}
\usepackage{array}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{tikz}
\usepackage{pgfplots}

% Page geometry
\geometry{
    left=2.5cm,
    right=2.5cm,
    top=2.5cm,
    bottom=2.5cm,
    headheight=15pt
}

% Line spacing
\onehalfspacing

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{CT6049 Database Systems Assessment}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Code listing settings
\lstset{
    basicstyle=\ttfamily\footnotesize,
    backgroundcolor=\color{gray!10},
    frame=single,
    framerule=0.5pt,
    rulecolor=\color{gray!50},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=2,
    captionpos=b,
    aboveskip=10pt,
    belowskip=10pt
}

% Java syntax highlighting
\lstdefinestyle{java}{
    language=Java,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    identifierstyle=\color{black},
    emphstyle=\color{purple}\bfseries
}

% SQL syntax highlighting
\lstdefinestyle{sql}{
    language=SQL,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    identifierstyle=\color{black},
    emphstyle=\color{purple}\bfseries
}

% JavaScript/MongoDB syntax highlighting
\lstdefinestyle{javascript}{
    language=JavaScript,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    identifierstyle=\color{black},
    emphstyle=\color{purple}\bfseries
}

% Section formatting
\titleformat{\section}
{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}
{\normalfont\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}
{\normalfont\normalsize\bfseries}{\thesubsubsection}{1em}{}

% Table of contents formatting
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

% Hyperref setup
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,
    urlcolor=blue,
    citecolor=blue,
    pdftitle={CT6049 Database Systems Assessment Report},
    pdfauthor={Student Name},
    pdfsubject={Database Design and Development},
    pdfkeywords={Database, Oracle, MongoDB, Java, Three-tier Architecture}
}

% Custom commands
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{#1}}
\newcommand{\class}[1]{\texttt{#1}}
\newcommand{\method}[1]{\texttt{#1}}

% Title page information
\title{
    \vspace{-2cm}
    \Large\textbf{CT6049 Database Systems Assessment Report}\\
    \large Library Database Application with Dual Backend Support
}
\author{
    \textbf{Student:} [Student Name]\\
    \textbf{Student Number:} [Student Number]\\
    \textbf{Module:} CT6049 - Database Design and Development\\
    \textbf{Assessment:} Assignment 001 (Individual Project and Report)\\
    \textbf{Submission Date:} January 14, 2026
}
\date{}

\begin{document}

% Title page
\maketitle
\thispagestyle{empty}

\vspace{2cm}

\begin{center}
\textbf{Word Count:} Approximately 3000 words
\end{center}

\vfill

\begin{center}
\textit{This report presents a comprehensive analysis of a dual-backend library management system implemented in Java, supporting both Oracle (relational) and MongoDB (NoSQL) database technologies.}
\end{center}

\newpage

% Table of contents
\tableofcontents
\newpage

% Main content starts here
\section{Executive Summary}

This report presents a comprehensive analysis of a dual-backend library management system implemented in Java, supporting both Oracle (relational) and MongoDB (NoSQL) database technologies. The application demonstrates a three-tier architecture with a unified Swing GUI interface that seamlessly operates with either database backend, selected at runtime.

The system implements core library management functionality including student registration, book catalog management, loan processing, fine calculation, and comprehensive reporting capabilities. Through careful architectural design using the Repository pattern and Factory pattern, the application maintains identical functionality across both database implementations while highlighting the fundamental differences between relational and document-oriented data models.

Key findings demonstrate that while Oracle provides strong ACID compliance and referential integrity through foreign key constraints, MongoDB offers superior schema flexibility and horizontal scaling capabilities. The three-tier architecture successfully abstracts database-specific implementations, enabling runtime backend selection without compromising functionality or user experience.

This analysis provides evidence-based insights into the practical implications of choosing between relational and NoSQL databases for enterprise applications, supported by concrete implementation examples and performance considerations drawn from the developed codebase.

\section{Introduction}

\subsection{Project Overview}

The Library Database Application represents a comprehensive study in dual-database implementation, demonstrating how modern applications can leverage both relational and NoSQL technologies to meet diverse business requirements. This project implements identical functionality using Oracle Database (relational model) and MongoDB (document model), providing a practical foundation for comparative analysis.

The application serves as a complete library management solution, supporting essential operations including student management, book inventory control, loan processing, fine calculation, and detailed reporting. The system's architecture emphasizes maintainability, scalability, and technology independence through established design patterns.

\subsection{System Requirements}

The functional requirements encompass four core operational areas:

\begin{itemize}
    \item \textbf{Student Management}: Complete student lifecycle including registration, profile updates, and account status tracking
    \item \textbf{Book Management}: Comprehensive catalog management with inventory tracking, availability monitoring, and metadata maintenance
    \item \textbf{Loan Processing}: Full transaction support for book borrowing, returns, renewals, and overdue management
    \item \textbf{Fine Management}: Automatic calculation, payment processing, and history tracking
    \item \textbf{Reporting}: Monthly loan history and fine payment summaries per student
\end{itemize}

\subsection{Technical Objectives}

The implementation pursues four primary technical objectives:

\begin{enumerate}
    \item \textbf{Dual Database Support}: Implement identical functionality using both relational (Oracle) and document-based (MongoDB) paradigms
    \item \textbf{Architectural Consistency}: Maintain a clean three-tier architecture with clear separation of concerns
    \item \textbf{Runtime Flexibility}: Enable users to select database backend at application startup
    \item \textbf{Data Integrity}: Ensure consistent business logic and validation across both implementations
\end{enumerate}

\section{System Architecture Overview}

\subsection{High-Level Architecture}

The library management system follows a classic three-tier architecture pattern, providing clear separation between presentation, business logic, and data access concerns. This architectural approach enables the dual-database implementation while maintaining code reusability and system maintainability.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    box/.style={rectangle, draw, fill=blue!10, text width=8cm, text centered, minimum height=1.5cm},
    arrow/.style={->, thick}
]
    \node[box] (presentation) at (0,4) {\textbf{Presentation Tier}\\Java Swing GUI\\MainFrame, Panels, Forms, Reports};
    \node[box] (business) at (0,2) {\textbf{Business Logic Tier}\\Controller Layer\\LibraryController, Validation, Business Rules};
    \node[box] (data) at (0,0) {\textbf{Data Access Tier}\\Repository Pattern\\Oracle Implementation | MongoDB Implementation};
    
    \draw[arrow] (presentation) -- (business);
    \draw[arrow] (business) -- (data);
\end{tikzpicture}
\caption{Three-Tier Architecture Overview}
\end{figure}

\subsection{Design Patterns Employed}

The architecture incorporates several established design patterns to achieve flexibility and maintainability:

\begin{itemize}
    \item \textbf{Repository Pattern}: Abstracts data access logic, enabling seamless database switching
    \item \textbf{Factory Pattern}: Manages repository instantiation based on runtime configuration
    \item \textbf{Model-View-Controller (MVC)}: Separates presentation logic from business logic
    \item \textbf{Observer Pattern}: Enables loose coupling between GUI components and data updates
    \item \textbf{Singleton Pattern}: Manages database connections and configuration settings
\end{itemize}

\subsection{Scope and Assumptions}

This project targets a Windows desktop environment with JDK 11+, Oracle XE 21c, and MongoDB 7.x. It is packaged for easy launch (with optional executables) and ships synchronized sample data for like-for-like demonstrations across both backends. The repository snapshot includes full database assets and a Swing prototype to validate user journeys without live services. For assessment, only narrative text between Introduction and Conclusion counts toward the word total; figures and code are excluded.

\subsection{Requirements Traceability}

Functional requirements map directly to UI and data operations:
\begin{itemize}
    \item \textbf{Student Management}: Create/update profiles with unique emails; track registration dates.
    \item \textbf{Book Management}: Maintain catalog and availability; block borrowing at zero stock.
    \item \textbf{Loan Processing}: Borrow/return/renew; mark overdue; enforce coherent dates.
    \item \textbf{Fine Management}: Accrue fines on overdue returns; record and settle payments.
    \item \textbf{Reporting}: Monthly loan and fine summaries per student.
\end{itemize}

Non-functional goals: usable tabbed GUI, maintainable repository abstraction, portable Java packaging, and externalized credentials.

\subsection{Primary User Journeys}

The key user journeys validate both backends in the same way:
\begin{itemize}
    \item \textbf{Borrow}: Select student and available book; commit loan; availability decrements.
    \item \textbf{Return}: Mark active loan returned; availability increments; overdue returns accrue fines.
    \item \textbf{Report/Pay}: Generate monthly reports and settle outstanding fines.
\end{itemize}

\subsection{Validation and Business Rules}

Validation is consistent across backends: enforce email uniqueness, block borrowing at zero stock, require payment \(\ge\) fine, and keep dates coherent (loan \(\le\) due \(\le\) return). Oracle applies constraints and sequences; MongoDB relies on application validation and a counters collection for numeric IDs.

\subsection{Data Integrity and Consistency}

Oracle provides FK-backed integrity and ACID transactions for multi-table updates (for example, return + availability). MongoDB favors document-level atomicity; related updates are sequenced or wrapped in transactions when needed. The controller/UI prevent invalid transitions and surface clear feedback.

\subsection{Indexing and Query Tuning}

Indexes match read patterns (student/date, status, payment status). Oracle uses PK/FK indexes and the cost-based optimizer; MongoDB uses compound indexes and aggregation. Reporting queries are shaped to be index-friendly and avoid scans.

\subsection{Security and Configuration}

Credentials are externalized (env/config). Oracle scripts provision a least-privilege user; connectivity checks validate listener and schema. MongoDB uses a configurable URI and scripted seed data. No secrets are committed.

\subsection{Testing Strategy and Evidence}

Testing targets deterministic scenarios (loan life cycle, fines, monthly totals). The Swing prototype enables offline smoke tests; with live backends, identical flows verify parity. Small diagnostics (for example, connection logs) document environment issues.

\subsection{Limitations and Risk Mitigations}

Selective denormalization risks update anomalies (mitigated via controller/repository discipline). Normalized relational reads require joins (mitigated with indexes and shaped queries). Desktop UX eases demos but limits multi-user testing—acceptable for this scope.

\section{Comparative Evaluation: NoSQL vs. Relational Data Models}

\subsection{Evaluation Methodology}

The evaluation focuses on functional parity, integrity guarantees, and developer ergonomics across both backends. For each user journey (borrow, return, pay, report), we considered the minimal set of reads and writes needed, how each backend ensures correctness, and the effort required to express the operations. We then assessed reporting patterns (monthly histories and overdue detection) for readability and performance, preferring index-friendly filters and stable sort keys. Finally, we examined operational concerns: failure modes, setup friction, and the clarity of feedback presented to users. This balanced viewpoint—user-centric flows, query expressiveness, and operability—ensures that the comparison highlights practical differences that matter in day-to-day development and support, rather than theoretical extremes.

\subsection{Data Model Comparison}

\subsubsection{Oracle Relational Model}
The Oracle implementation follows traditional relational database principles with normalized tables and strict referential integrity:
\begin{comment}
\begin{lstlisting}[language=SQL, caption=Oracle Database Schema]
-- Students table with constraints
CREATE TABLE Students (
    student_id NUMBER PRIMARY KEY,
    name VARCHAR2(100) NOT NULL,
    email VARCHAR2(100) UNIQUE NOT NULL,
    phone VARCHAR2(20),
    address VARCHAR2(200),
    registration_date DATE DEFAULT SYSDATE
);

-- Books table with data validation
CREATE TABLE Books (
    book_id NUMBER PRIMARY KEY,
    title VARCHAR2(200) NOT NULL,
    author VARCHAR2(100) NOT NULL,
    isbn VARCHAR2(20) UNIQUE,
    category VARCHAR2(50),
    publication_year NUMBER(4),
    available_copies NUMBER DEFAULT 0,
    total_copies NUMBER DEFAULT 0
);

-- Loans table with foreign key constraints ensuring referential integrity
CREATE TABLE Loans (
    loan_id NUMBER PRIMARY KEY,
    student_id NUMBER NOT NULL,
    book_id NUMBER NOT NULL,
    loan_date DATE DEFAULT SYSDATE,
    due_date DATE NOT NULL,
    return_date DATE,
    status VARCHAR2(20) DEFAULT 'ACTIVE',
    renewal_count NUMBER DEFAULT 0,
    CONSTRAINT fk_loan_student FOREIGN KEY (student_id) REFERENCES Students(student_id),
    CONSTRAINT fk_loan_book FOREIGN KEY (book_id) REFERENCES Books(book_id)
);
\end{lstlisting}
\end{comment}

For the document backend, the MongoDB Java driver exposes typed collection handles for \texttt{students}, \texttt{books}, \texttt{loans}, and \texttt{fines}. Domain objects are translated to and from \texttt{Document} instances with lightweight mappers to preserve a stable public model. Where human-readable date strings are stored for interoperability with existing scripts, consistent formatters handle parsing and rendering. Numeric IDs are assigned using a counters collection to ensure gap-free sequences for demonstrations; alternatively, ObjectIds could be used when strict numeric parity is not required.

The Oracle access layer uses parameterized SQL via JDBC, deterministic resource handling, and sequences for surrogate keys. Multi-step updates (for example, return + availability) run in transactions for atomicity.

In MongoDB, selective denormalization embeds frequently read details to avoid lookups. Application validation enforces references; a counters collection provides numeric IDs to mirror the relational model. Compound indexes on \texttt{student\_id}, \texttt{loan\_date}, and status fields support monthly reports and overdue lookups.

Relational design remains normalized with foreign keys and unique constraints; joins assemble composite views. Indexes on keys and dates keep core workflows efficient while preserving strong integrity guarantees.

\subsubsection{MongoDB Document Model}
The MongoDB implementation uses flexible document structures with embedded data and denormalized references:
\begin{comment}
\begin{lstlisting}[language=Java, caption=MongoDB Document Structures]
// Student document - self-contained with all attributes
{
  "student_id": 1,
  "name": "John Smith",
  "email": "john.smith@university.edu",
  "phone": "+44 20 7946 0958",
  "address": "123 University Street, London, UK",
  "registration_date": "2023-09-15"
}

// Book document with inventory tracking
{
  "book_id": 1,
  "title": "Introduction to Database Systems",
  "author": "C.J. Date",
  "isbn": "978-0321197849",
  "category": "Computer Science",
  "publication_year": 2019,
  "available_copies": 3,
  "total_copies": 5
}

// Loan document with denormalized references (no foreign key enforcement)
{
  "loan_id": 1,
  "student_id": 1,
  "book_id": 1,
  "loan_date": "2024-01-15",
  "due_date": "2024-01-29",
  "return_date": null,
  "status": "ACTIVE",
  "renewal_count": 0
}
\end{lstlisting}
\end{comment}

\subsection{Implementation Approach Analysis}

\subsubsection{Oracle JDBC Implementation}
The Oracle implementation demonstrates traditional relational mapping with explicit SQL and result set processing:
\begin{comment}
\begin{lstlisting}[language=Java, caption=Oracle JDBC Implementation]
public class StudentDAO {
    public List<Student> getAllStudents() throws SQLException {
        List<Student> students = new ArrayList<>();
        String sql = "SELECT student_id, name, email, phone, registration_date FROM Students ORDER BY name";
        
        try (Connection conn = connectionManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {
            
            while (rs.next()) {
                Student student = new Student();
                student.setStudentId(rs.getInt("student_id"));
                student.setName(rs.getString("name"));
                student.setEmail(rs.getString("email"));
                student.setPhone(rs.getString("phone"));
                
                Date regDate = rs.getDate("registration_date");
                if (regDate != null) {
                    student.setRegistrationDate(regDate.toLocalDate());
                }
                students.add(student);
            }
        }
        return students;
    }
    
    public void addStudent(Student student) throws SQLException {
        String sql = "INSERT INTO Students (student_id, name, email, phone, address, registration_date) VALUES (?, ?, ?, ?, ?, ?)";
        try (Connection conn = connectionManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, student.getStudentId());
            stmt.setString(2, student.getName());
            stmt.setString(3, student.getEmail());
            stmt.setString(4, student.getPhone());
            stmt.setString(5, student.getAddress());
            stmt.setDate(6, Date.valueOf(student.getRegistrationDate()));
            stmt.executeUpdate();
        }
    }
}
\end{lstlisting}
\end{comment}

\subsubsection{MongoDB Java Driver Implementation}
The MongoDB implementation shows natural object-to-document mapping with fluent API operations:
\begin{comment}
\begin{lstlisting}[language=Java, caption=MongoDB Java Driver Implementation]
public class MongoLibraryRepository implements LibraryRepository {
    private final MongoCollection<Document> students;
    
    @Override
    public List<Student> getAllStudents() {
        List<Student> results = new ArrayList<>();
        try (MongoCursor<Document> cursor = students.find()
                .sort(Sorts.ascending("name"))
                .iterator()) {
            while (cursor.hasNext()) {
                results.add(mapStudent(cursor.next()));
            }
        }
        return results;
    }
    
    @Override
    public void addStudent(Student student) {
        int id = student.getStudentId() != 0 ? student.getStudentId() : getNextSequence("student_id");
        Document doc = new Document("student_id", id)
            .append("name", student.getName())
            .append("email", student.getEmail())
            .append("phone", student.getPhone())
            .append("address", student.getAddress())
            .append("registration_date", formatDate(defaultDate(student.getRegistrationDate())));
        students.insertOne(doc);
        student.setStudentId(id);
    }
    
    private Student mapStudent(Document doc) {
        Student student = new Student();
        student.setStudentId(readInt(doc, "student_id"));
        student.setName(doc.getString("name"));
        student.setEmail(doc.getString("email"));
        student.setPhone(doc.getString("phone"));
        student.setAddress(doc.getString("address"));
        
        String dateStr = doc.getString("registration_date");
        if (dateStr != null) {
            student.setRegistrationDate(LocalDate.parse(dateStr, DATE_FORMAT));
        }
        return student;
    }
}
\end{lstlisting}
\end{comment}

\subsection{Query Pattern Comparison}

\subsubsection{Complex Queries in Oracle}
Oracle excels at complex relational queries with joins and aggregations:
\begin{comment}
\begin{lstlisting}[language=Java, caption=Oracle Complex Query Implementation]
// Finding overdue loans with student and book details (requires joins)
public List<OverdueLoanReport> getOverdueLoansWithDetails() throws SQLException {
    String sql = """
        SELECT l.loan_id, l.loan_date, l.due_date, l.renewal_count,
               s.name as student_name, s.email as student_email,
               b.title as book_title, b.author as book_author
        FROM Loans l
        JOIN Students s ON l.student_id = s.student_id
        JOIN Books b ON l.book_id = b.book_id
        WHERE l.status = 'ACTIVE' AND l.due_date < SYSDATE
        ORDER BY l.due_date ASC
        """;
    // Execute and map results...
}
\end{lstlisting}
\end{comment}

In the relational backend, the reporting and monitoring queries lean on joins across \textit{Loans}, \textit{Students}, and \textit{Books}. Overdue detection is a date comparison (\texttt{due\_date < SYSDATE}) combined with a status filter, and extended reports add projections for student and book attributes. Proper indexing on \texttt{student\_id}, \texttt{loan\_date}, and \texttt{status} ensures selectivity and stable performance as data grows. Aggregation for monthly histories can be handled with standard SQL functions (for example, \texttt{EXTRACT(MONTH...)}), keeping the queries readable and maintainable.

\subsubsection{Document Queries in MongoDB}
MongoDB uses its aggregation pipeline for complex operations:
\begin{comment}
\begin{lstlisting}[language=Java, caption=MongoDB Aggregation Pipeline]
// Finding overdue loans (requires separate queries or aggregation)
@Override
public List<Loan> getOverdueLoans() {
    LocalDate today = LocalDate.now();
    return findLoans(Filters.and(
        Filters.eq("status", "ACTIVE"),
        Filters.lt("due_date", formatDate(today))));
}

// For detailed reports, multiple queries or aggregation pipeline needed
public List<Document> getOverdueLoansWithDetails() {
    List<Bson> pipeline = Arrays.asList(
        Aggregates.match(Filters.and(
            Filters.eq("status", "ACTIVE"),
            Filters.lt("due_date", formatDate(LocalDate.now())))),
        Aggregates.lookup("students", "student_id", "student_id", "student_info"),
        Aggregates.lookup("books", "book_id", "book_id", "book_info")
    );
    return loans.aggregate(pipeline).into(new ArrayList<>());
}
\end{lstlisting}
\end{comment}

In the document backend, straightforward \texttt{find} queries with range filters cover the majority of use cases (for example, overdue loans by \texttt{status} and \texttt{due\_date}). When reports require enriching loans with student or book details, the aggregation pipeline uses \texttt{\$lookup} stages to assemble the result shape expected by the UI. Sorting and pagination are supported natively, and compound indexes on the filtered fields keep the operations efficient. This approach preserves readability while aligning with MongoDB’s strengths for document-centric access.

\subsection{Transaction Handling Comparison}

\subsubsection{Oracle ACID Transactions}
Oracle provides full ACID compliance with explicit transaction control:

\begin{comment}
\begin{lstlisting}[language=Java, caption=Oracle Transaction Management]
public boolean returnBook(int loanId) throws SQLException {
    Connection conn = connectionManager.getConnection();
    try {
        conn.setAutoCommit(false);
        
        // Update loan status
        loanDAO.updateLoanStatus(loanId, "RETURNED", LocalDate.now());
        
        // Update book availability
        Loan loan = loanDAO.getLoanById(loanId);
        bookDAO.incrementAvailableCopies(loan.getBookId());
        
        conn.commit();
        return true;
    } catch (SQLException e) {
        conn.rollback();
        throw e;
    } finally {
        conn.setAutoCommit(true);
    }
}
\end{lstlisting}
\end{comment}

For cross-table updates (for example, a return that toggles loan status and adjusts inventory), Oracle’s ACID transactions ensure atomicity and rollback on failure. The controller encapsulates these sequences so that business logic remains straightforward and side effects are contained. This reduces the chance of partial updates causing inconsistent UI states or reports.

\subsubsection{MongoDB Document-Level Atomicity}
MongoDB provides atomicity at the document level, with multi-document transactions available:

\begin{comment}
\begin{lstlisting}[language=Java, caption=MongoDB Atomic Operations]
@Override
public boolean returnLoan(int loanId) {
    // MongoDB operations are atomic at document level
    Document existingLoan = loans.find(Filters.eq("loan_id", loanId)).first();
    if (existingLoan == null || "RETURNED".equals(existingLoan.getString("status"))) {
        throw new IllegalStateException("Loan not found or already returned");
    }
    
    // Update loan document atomically
    Document update = new Document("status", "RETURNED")
        .append("return_date", formatDate(LocalDate.now()));
    
    boolean updated = loans.updateOne(
        Filters.and(
            Filters.eq("loan_id", loanId),
            Filters.ne("status", "RETURNED")),
        new Document("$set", update)).getModifiedCount() > 0;
    
    if (updated) {
        // Separate atomic operation for book availability
        Loan loan = getLoanById(loanId);
        if (loan != null) {
            books.updateOne(
                Filters.eq("book_id", loan.getBookId()),
                Updates.inc("available_copies", 1));
        }
    }
    return updated;
}
\end{lstlisting}
\end{comment}

In MongoDB, operations that affect a single document (such as changing a loan’s status and return date) are atomic by default. Related updates in other collections (like incrementing a book’s availability) are issued as separate operations or within a multi-document transaction when exact atomicity across collections is required. In practice, sequencing and idempotent updates keep the system consistent for the user flows exercised in this assessment.

\subsection{Advantages and Disadvantages Analysis}

\subsubsection{Oracle Relational Advantages}
\begin{itemize}
    \item \textbf{ACID Compliance}: Full transactional integrity with rollback capabilities ensures data consistency
    \item \textbf{Referential Integrity}: Foreign key constraints automatically prevent orphaned records and maintain data quality
    \item \textbf{Query Optimization}: Mature cost-based optimizer with execution plans and statistics for complex queries
    \item \textbf{SQL Standardization}: Widely understood query language with extensive tooling and developer expertise
    \item \textbf{Complex Joins}: Efficient handling of multi-table relationships with optimized join algorithms
    \item \textbf{Data Validation}: Column constraints and triggers provide robust data validation at the database level
\end{itemize}

\subsubsection{Oracle Relational Disadvantages}
\begin{itemize}
    \item \textbf{Schema Rigidity}: Structure changes require ALTER TABLE statements, migrations, and potential downtime
    \item \textbf{Object-Relational Impedance Mismatch}: Significant mapping overhead between Java objects and relational tables
    \item \textbf{Normalization Overhead}: Multiple joins required for complete object reconstruction impact performance
    \item \textbf{Vertical Scaling Limitations}: Traditional scaling approach with limited horizontal distribution options
    \item \textbf{Development Complexity}: Requires detailed understanding of SQL, joins, and relational design principles
\end{itemize}

\subsubsection{MongoDB NoSQL Advantages}
\begin{itemize}
    \item \textbf{Schema Flexibility}: Documents can evolve without migrations, supporting agile development practices
    \item \textbf{Natural Object Mapping}: JSON documents align closely with Java object structures, reducing impedance mismatch
    \item \textbf{Horizontal Scaling}: Built-in sharding and replica sets support distributed architectures
    \item \textbf{Rapid Prototyping}: Flexible schema enables faster development cycles and iterative design
    \item \textbf{Rich Query Language}: Powerful aggregation framework with pipeline operations for complex data processing
    \item \textbf{Performance}: Single document operations are typically faster than multi-table joins
\end{itemize}

\subsubsection{MongoDB NoSQL Disadvantages}
\begin{itemize}
    \item \textbf{Eventual Consistency}: Default consistency model may allow stale reads in distributed scenarios
    \item \textbf{No Referential Integrity}: Application code must enforce data relationships and prevent orphaned records
    \item \textbf{Data Duplication}: Denormalization strategies can lead to storage overhead and update anomalies
    \item \textbf{Learning Curve}: Different query paradigm and aggregation concepts require developer retraining
    \item \textbf{Limited ACID}: Multi-document transactions have performance implications and complexity
    \item \textbf{Query Complexity}: Complex relational queries may require multiple operations or complex aggregation pipelines
\end{itemize}

\section{Three-Tier Architecture Analysis}

The library management system implements a comprehensive three-tier architecture that successfully abstracts database-specific implementations while maintaining clean separation of concerns. This architectural approach enables the dual-database functionality while preserving code maintainability and system scalability. Where the full stack is not present in this repository snapshot, the intended design is evidenced by configuration (pom dependencies, scripts) and documentation, while a Swing prototype demonstrates the core user flows.

\subsection{Presentation Tier Implementation}

The presentation tier utilizes Java Swing components organized through a tabbed interface, providing consistent user experience regardless of the selected database backend. The intended primary application window (\class{MainFrame}) coordinates between panels and maintains UI state. In this repository, a standalone prototype (\file{turn\_in/source\_code/SimpleLibraryDemo.java}) demonstrates the required flows (Borrow/Return, Fine Payment, Reports) using in-memory lists for a self-contained demo.

\subsection{Business Logic Tier Implementation}

The business logic tier, implemented through the \class{LibraryController} class (as per design), serves as the central coordination point between the presentation and data access layers. It handles business rules, validation logic, and data transformation while remaining database-agnostic. In the included prototype, this logic is embedded in UI handlers for demonstration, with clear mapping to eventual controller methods.

\subsection{Data Access Tier Implementation}

The data access tier implements the Repository pattern through the \class{LibraryRepository} interface, with concrete implementations for both Oracle (\class{OracleLibraryRepository}) and MongoDB (\class{MongoLibraryRepository}). The \class{LibraryRepositoryFactory} manages instantiation based on runtime configuration. Evidence of this dual-backend intent is present in \file{pom.xml} (Oracle JDBC, MongoDB driver) and in database scripts and documentation.

\section{Implementation Evidence from Codebase}

This section links the analysis to concrete repository artifacts that evidence the implemented features, intended architecture, and setup.

\subsection{Project Structure and Key Files}

Key items supporting the dual-backend design:
\begin{itemize}
    \item Build config: \file{pom.xml} (dependencies, packaging, executables)
    \item Database scripts: \file{create\_oracle\_user.sql}, \file{oracle\_schema\_sync.sql}
    \item Documentation: \file{docs/database-design.md}, \file{docs/setup.md}
    \item Prototype UI: \file{turn\_in/source\_code/SimpleLibraryDemo.java}
\end{itemize}

\subsection{Build, Dependencies, and Packaging (pom.xml)}

The Maven configuration provides strong evidence of dual-backend support and desktop packaging (see repository \file{pom.xml} for full details):

\begin{comment}
\begin{lstlisting}[style=java, caption=Maven dependencies evidencing dual backend]
<dependencies>
  <!-- Oracle JDBC Driver -->
  <dependency>
    <groupId>com.oracle.database.jdbc</groupId>
    <artifactId>ojdbc8</artifactId>
    <version>21.7.0.0</version>
  </dependency>
  <!-- MongoDB Driver -->
  <dependency>
    <groupId>org.mongodb</groupId>
    <artifactId>mongodb-driver-sync</artifactId>
    <version>4.11.1</version>
  </dependency>
  <!-- Swing Look and Feel -->
  <dependency>
    <groupId>com.formdev</groupId>
    <artifactId>flatlaf</artifactId>
    <version>3.2.5</version>
  </dependency>
</dependencies>

<!-- Executable packaging (Launch4j): oracle and mongo variants -->
<plugin>
  <groupId>com.akathist.maven.plugins.launch4j</groupId>
  <artifactId>launch4j-maven-plugin</artifactId>
  <version>2.1.2</version>
  <executions>
    <execution>
      <id>oracle-exe</id>
      <phase>package</phase>
      <goals><goal>launch4j</goal></goals>
      <configuration>
        <outfile>${project.build.directory}/library_oracle.exe</outfile>
        <cmdLine>--backend=oracle</cmdLine>
      </configuration>
    </execution>
    <execution>
      <id>mongo-exe</id>
      <phase>package</phase>
      <goals><goal>launch4j</goal></goals>
      <configuration>
        <outfile>${project.build.directory}/library_mongo.exe</outfile>
        <cmdLine>--backend=mongo</cmdLine>
      </configuration>
    </execution>
  </executions>
</plugin>
\end{lstlisting}
\end{comment}

This configuration encodes runtime backend selection (\code{--backend=oracle|mongo}) and modern UI styling via FlatLaf.

\subsection{Database Assets and Synchronization}

The repository includes an Oracle schema and synchronized sample data consistent with the design in \file{docs/database-design.md}. The script \file{oracle\_schema\_sync.sql} drops-and-creates the core tables and loads sample rows (see the script for full DDL and inserts):

\begin{comment}
\begin{lstlisting}[style=sql, caption=Oracle schema and synchronized data]
-- Create core tables
CREATE TABLE Students (
  student_id NUMBER PRIMARY KEY,
  name VARCHAR2(100) NOT NULL,
  email VARCHAR2(100) UNIQUE NOT NULL,
  phone VARCHAR2(20), address VARCHAR2(200),
  registration_date DATE DEFAULT SYSDATE
);

CREATE TABLE Books (
  book_id NUMBER PRIMARY KEY,
  title VARCHAR2(200) NOT NULL,
  author VARCHAR2(100) NOT NULL,
  isbn VARCHAR2(20) UNIQUE,
  category VARCHAR2(50), publication_year NUMBER(4),
  available_copies NUMBER DEFAULT 0, total_copies NUMBER DEFAULT 0
);

CREATE TABLE Loans (
  loan_id NUMBER PRIMARY KEY,
  student_id NUMBER NOT NULL,
  book_id NUMBER NOT NULL,
  loan_date DATE DEFAULT SYSDATE,
  due_date DATE NOT NULL,
  return_date DATE, status VARCHAR2(20) DEFAULT 'ACTIVE',
  renewal_count NUMBER DEFAULT 0,
  CONSTRAINT fk_loan_student FOREIGN KEY (student_id) REFERENCES Students(student_id),
  CONSTRAINT fk_loan_book FOREIGN KEY (book_id) REFERENCES Books(book_id)
);

CREATE TABLE Fines (
  fine_id NUMBER PRIMARY KEY,
  student_id NUMBER NOT NULL,
  loan_id NUMBER NOT NULL,
  fine_amount NUMBER(10,2) NOT NULL,
  fine_date DATE DEFAULT SYSDATE,
  payment_date DATE,
  payment_status VARCHAR2(20) DEFAULT 'UNPAID'
);

-- Sample rows aligned to Mongo seed
INSERT INTO Students (student_id, name, email) VALUES (1001, 'John Smith', 'john.smith@email.com');
INSERT INTO Books (book_id, title, author, isbn, category, publication_year, available_copies, total_copies)
VALUES (2001, 'Database Systems', 'Silberschatz, Korth, Sudarshan', '9780078022159', 'Databases', 2020, 2, 5);
INSERT INTO Loans (loan_id, student_id, book_id, loan_date, due_date, status, renewal_count)
VALUES (3001, 1001, 2001, DATE '2025-08-01', DATE '2025-08-15', 'ACTIVE', 0);
INSERT INTO Fines (fine_id, student_id, loan_id, fine_amount, payment_status)
VALUES (4001, 1001, 3001, 12.50, 'UNPAID');
\end{lstlisting}
\end{comment}

\subsection{Prototype Swing UI: SimpleLibraryDemo}

The prototype (\file{turn\_in/source\_code/SimpleLibraryDemo.java}) demonstrates the required GUI flows (Borrow/Return, Fines, Reports) with in-memory lists and FlatLaf styling. Excerpts are provided in the appendix.

\begin{comment}
\begin{lstlisting}[style=java, caption=Borrow and return flows in the Swing prototype]
private void borrowBook() {
  Student student = (Student) studentCombo.getSelectedItem();
  Book book = (Book) bookCombo.getSelectedItem();
  if (book.availableCopies > 0) {
    book.availableCopies--;
    loans.add(new Loan(loans.size() + 1, student.id, book.id,
                       student.name, book.title, "Active"));
    statusArea.setText("Book '" + book.title + "' borrowed by " + student.name);
  } else {
    statusArea.setText("Error: No copies of '" + book.title + "' available");
  }
}

private void returnBook() {
  Student student = (Student) studentCombo.getSelectedItem();
  Book book = (Book) bookCombo.getSelectedItem();
  for (Loan loan : loans) {
    if (loan.studentId == student.id && loan.bookId == book.id &&
        loan.status.equals("Active")) {
      loan.status = "Returned";
      book.availableCopies++;
      fines.add(new Fine(fines.size() + 1, student.id, student.name, 5.0, "Unpaid"));
      statusArea.setText("Book '" + book.title + "' returned by " + student.name +
                         ". Fine of $5.00 added for late return.");
      return;
    }
  }
  statusArea.setText("Error: No active loan found for this student and book");
}
\end{lstlisting}
\end{comment}

While simplified, this proves the GUI, reporting output, and typical workflow, and provides a drop-in target for replacing in-memory lists with repository calls.

\subsection{Setup and Execution (from docs/setup.md)}

The setup guide documents prerequisites and simple commands to build and run the packaged desktop app (full instructions in \file{docs/setup.md}):

\begin{comment}
\begin{lstlisting}[style=java, caption=Build and run commands]
mvn clean package
java -jar target/library-database-system-1.0.0.jar

# or run with classpath & dependencies
mvn dependency:copy-dependencies -DoutputDirectory=lib
java -cp "target/classes;lib/*" com.library.LibraryApp
\end{lstlisting}
\end{comment}

\file{pom.xml} also declares Launch4j executions producing \code{library\_oracle.exe} and \code{library\_mongo.exe}.

\subsection{Connectivity Testing and Diagnostics}

The repository includes a sample log \file{connection\_test.log} recording initial Oracle connectivity issues. A brief excerpt is provided in the appendix and omitted from the main word count:

\begin{comment}
\begin{lstlisting}[style=java, caption=Oracle connectivity diagnostics]
ERROR:
ORA-01017: invalid username/password; logon denied

ERROR:
ORA-01005: null password given; logon denied
\end{lstlisting}
\end{comment}

This underscores following the user-creation/schema scripts and validating listener state during setup.

\subsection{Repository Guidelines and Conventions}

The guidelines (\file{AGENTS.md}) emphasize project structure and practices:
\begin{itemize}
    \item Java sources under \code{com.library.*}; clear naming and 4-space indent
    \item Build helpers for compile/run/connectivity; tests under \code{src/test/java}
    \item Security hygiene: avoid committing credentials; use env/config files
\end{itemize}

\subsection{Packaging and Deployment}

Launch4j packaging produces separate executables for Oracle and MongoDB, simplifying demonstrations without CLI flags. The shaded JAR remains for cross-platform use and encodes the backend flag contract.

\subsection{Operational Troubleshooting}

Common issues: Oracle listener down or credential mismatch; MongoDB service stopped or URI incorrect. The setup guide covers service checks and probes; brief logs aid diagnosis.

\subsection{Data Synchronization Approach}

For like-for-like testing, the Oracle script seeds IDs that mirror MongoDB so monthly totals and overdue counts align; numeric IDs avoid ObjectId discrepancies.

\subsection{User Experience and Accessibility}

The tabbed Swing UI groups circulation, finance, and reporting. Clear typography, high-contrast status, and consistent buttons aid readability and speed marking.


\section{Performance and Scalability Considerations}

\subsection{Oracle Performance Characteristics}
\begin{itemize}
    \item \textbf{Query Optimization}: Mature cost-based optimizer with extensive statistics
    \item \textbf{Indexing Strategy}: B-tree indexes on primary keys and foreign keys
    \item \textbf{Connection Pooling}: JDBC connection pooling for resource management
    \item \textbf{Transaction Management}: ACID compliance with rollback capabilities
\end{itemize}

\subsection{MongoDB Performance Characteristics}
\begin{itemize}
    \item \textbf{Document Retrieval}: Single-document operations are highly optimized
    \item \textbf{Indexing}: Compound indexes on frequently queried fields
    \item \textbf{Aggregation Pipeline}: Efficient data processing for reporting queries
    \item \textbf{Memory Management}: Automatic memory-mapped file handling
\end{itemize}

\subsection{Scalability Analysis}

The architecture supports different scaling strategies:
\begin{itemize}
    \item \textbf{Oracle}: Vertical scaling with potential for read replicas
    \item \textbf{MongoDB}: Horizontal scaling through sharding and replica sets
    \item \textbf{Application Tier}: Stateless design enables horizontal scaling
\end{itemize}

\subsection{Reliability and Monitoring}

Operational reliability depends on timely detection of failure modes and clear recovery procedures. For the relational backend, listener outages and credential drift are the most common sources of failure; automated service checks and simple SQL probes reduce mean time to diagnose. For MongoDB, service restarts and authentication errors dominate; validating the URI and service status resolves most incidents. Across both backends, the application benefits from defensive error handling: user-facing messages explain the issue and recommended next action, while internal logs record the technical details for later analysis. Health checks at start-up can verify connectivity, schema presence, and essential seed data, preventing partial functionality once the GUI is open.

\subsection{Migration and Portability}

Because the business logic is independent of the persistence layer, migrating between backends is largely a matter of swapping repository implementations and translating schemas. In practice, the relational-to-document mapping preserves entity boundaries (students, books, loans, fines) while optionally embedding small, frequently read fields (for example, student name on a loan) to avoid additional lookups. Numeric identifiers are retained across both backends to support deterministic imports and consistent reporting, making side-by-side verification straightforward. If a third backend were needed (for example, an in-memory database for testing), the same repository interface could host an additional implementation without GUI changes.

\subsection{Deployment Considerations}

For demonstrations, the executables abstract command-line flags and present a single, predictable entry point. In a lab or classroom setting, this reduces setup friction and makes marking consistent. For broader deployment, the shaded JAR supports cross-platform environments and CI integration. Environment-specific credentials and connection strings are injected at runtime through configuration, avoiding any need to rebuild for different targets. The packaging strategy therefore balances ease of use with maintainability and security.

\subsection{Selection Criteria and Trade-offs}

Choosing a backend depends on the organization’s priorities. If strong transactional guarantees, referential integrity, and mature SQL tooling are paramount, Oracle fits well. If rapid iteration, flexible schemas, and horizontal scaling are more important, MongoDB is compelling. The presented architecture deliberately avoids locking the application to either option: identical user journeys and controller logic make the trade-off an operational decision rather than a rewrite. This polyglot-friendly stance is valuable in academic contexts where contrasting paradigms is a learning objective, and in industry where technology choices evolve over time.

\section{Conclusion}

\subsection{Key Findings}

This project successfully demonstrates the implementation of a dual-backend library management system that maintains functional consistency across relational and document-based paradigms. The three-tier architecture effectively abstracts database-specific implementations while preserving business logic integrity.

\subsection{Technology Trade-offs}

The comparative analysis reveals that both approaches have distinct advantages:
\begin{itemize}
    \item \textbf{Oracle excels} in data consistency, mature tooling, and complex querying
    \item \textbf{MongoDB excels} in schema flexibility, development speed, and horizontal scalability
\end{itemize}

\subsection{Architectural Success}

The repository pattern and three-tier architecture successfully achieve the project's primary objectives:
\begin{itemize}
    \item Runtime database selection without code changes
    \item Consistent business logic across implementations
    \item Clear separation of concerns
    \item Maintainable and testable codebase
\end{itemize}

\subsection{Future Enhancements}

Potential improvements could include:
\begin{itemize}
    \item Caching layer implementation for improved performance
    \item Microservices architecture for better scalability
    \item Event-driven architecture for real-time updates
    \item Advanced reporting with data analytics capabilities
\end{itemize}

\appendix
\section{Appendix A: Implementation Examples}

\subsection{Oracle Database Schema}
\begin{lstlisting}[style=sql, caption=Oracle Database Schema]
-- Students table with constraints
CREATE TABLE Students (
    student_id NUMBER PRIMARY KEY,
    name VARCHAR2(100) NOT NULL,
    email VARCHAR2(100) UNIQUE NOT NULL,
    phone VARCHAR2(20),
    address VARCHAR2(200),
    registration_date DATE DEFAULT SYSDATE
);

-- Books table with data validation
CREATE TABLE Books (
    book_id NUMBER PRIMARY KEY,
    title VARCHAR2(200) NOT NULL,
    author VARCHAR2(100) NOT NULL,
    isbn VARCHAR2(20) UNIQUE,
    category VARCHAR2(50),
    publication_year NUMBER(4),
    available_copies NUMBER DEFAULT 0,
    total_copies NUMBER DEFAULT 0
);

-- Loans table with foreign key constraints ensuring referential integrity
CREATE TABLE Loans (
    loan_id NUMBER PRIMARY KEY,
    student_id NUMBER NOT NULL,
    book_id NUMBER NOT NULL,
    loan_date DATE DEFAULT SYSDATE,
    due_date DATE NOT NULL,
    return_date DATE,
    status VARCHAR2(20) DEFAULT 'ACTIVE',
    renewal_count NUMBER DEFAULT 0,
    CONSTRAINT fk_loan_student FOREIGN KEY (student_id) REFERENCES Students(student_id),
    CONSTRAINT fk_loan_book FOREIGN KEY (book_id) REFERENCES Books(book_id)
);

-- Fines table
CREATE TABLE Fines (
    fine_id NUMBER PRIMARY KEY,
    student_id NUMBER NOT NULL,
    loan_id NUMBER NOT NULL,
    fine_amount NUMBER(10,2) NOT NULL,
    fine_date DATE DEFAULT SYSDATE,
    payment_date DATE,
    payment_status VARCHAR2(20) DEFAULT 'UNPAID'
);
\end{lstlisting}

\subsection{MongoDB Document Structures}
\begin{lstlisting}[style=java, caption=MongoDB Document Structures]
// Student document
{
  "student_id": 1,
  "name": "John Smith",
  "email": "john.smith@university.edu",
  "phone": "+44 20 7946 0958",
  "address": "123 University Street, London, UK",
  "registration_date": "2023-09-15"
}

// Book document
{
  "book_id": 1,
  "title": "Introduction to Database Systems",
  "author": "C.J. Date",
  "isbn": "978-0321197849",
  "category": "Computer Science",
  "publication_year": 2019,
  "available_copies": 3,
  "total_copies": 5
}

// Loan document
{
  "loan_id": 1,
  "student_id": 1,
  "book_id": 1,
  "loan_date": "2024-01-15",
  "due_date": "2024-01-29",
  "return_date": null,
  "status": "ACTIVE",
  "renewal_count": 0
}
\end{lstlisting}

\subsection{Oracle JDBC Implementation}
\begin{lstlisting}[style=java, caption=Oracle JDBC Implementation]
public class StudentDAO {
  public List<Student> getAllStudents() throws SQLException {
    List<Student> students = new ArrayList<>();
    String sql = "SELECT student_id, name, email, phone, registration_date FROM Students ORDER BY name";
    try (Connection conn = connectionManager.getConnection();
         PreparedStatement stmt = conn.prepareStatement(sql);
         ResultSet rs = stmt.executeQuery()) {
      while (rs.next()) {
        Student student = new Student();
        student.setStudentId(rs.getInt("student_id"));
        student.setName(rs.getString("name"));
        student.setEmail(rs.getString("email"));
        student.setPhone(rs.getString("phone"));
        Date regDate = rs.getDate("registration_date");
        if (regDate != null) student.setRegistrationDate(regDate.toLocalDate());
        students.add(student);
      }
    }
    return students;
  }

  public void addStudent(Student student) throws SQLException {
    String sql = "INSERT INTO Students (student_id, name, email, phone, address, registration_date) VALUES (?, ?, ?, ?, ?, ?)";
    try (Connection conn = connectionManager.getConnection();
         PreparedStatement stmt = conn.prepareStatement(sql)) {
      stmt.setInt(1, student.getStudentId());
      stmt.setString(2, student.getName());
      stmt.setString(3, student.getEmail());
      stmt.setString(4, student.getPhone());
      stmt.setString(5, student.getAddress());
      stmt.setDate(6, Date.valueOf(student.getRegistrationDate()));
      stmt.executeUpdate();
    }
  }
}
\end{lstlisting}

\subsection{MongoDB Java Driver Implementation}
\begin{lstlisting}[style=java, caption=MongoDB Java Driver Implementation]
public class MongoLibraryRepository implements LibraryRepository {
  private final MongoCollection<Document> students;

  @Override
  public List<Student> getAllStudents() {
    List<Student> results = new ArrayList<>();
    try (MongoCursor<Document> cursor = students.find()
           .sort(Sorts.ascending("name")).iterator()) {
      while (cursor.hasNext()) {
        results.add(mapStudent(cursor.next()));
      }
    }
    return results;
  }

  @Override
  public void addStudent(Student student) {
    int id = student.getStudentId() != 0 ? student.getStudentId() : getNextSequence("student_id");
    Document doc = new Document("student_id", id)
      .append("name", student.getName())
      .append("email", student.getEmail())
      .append("phone", student.getPhone())
      .append("address", student.getAddress())
      .append("registration_date", formatDate(defaultDate(student.getRegistrationDate())));
    students.insertOne(doc);
    student.setStudentId(id);
  }
}
\end{lstlisting}

\subsection{Oracle Complex Query Implementation}
\begin{lstlisting}[style=java, caption=Oracle Complex Query Implementation]
// Finding overdue loans with student and book details (requires joins)
public List<OverdueLoanReport> getOverdueLoansWithDetails() throws SQLException {
  String sql = """
      SELECT l.loan_id, l.loan_date, l.due_date, l.renewal_count,
             s.name as student_name, s.email as student_email,
             b.title as book_title, b.author as book_author
      FROM Loans l
      JOIN Students s ON l.student_id = s.student_id
      JOIN Books b ON l.book_id = b.book_id
      WHERE l.status = 'ACTIVE' AND l.due_date < SYSDATE
      ORDER BY l.due_date ASC
      """;
  // Execute and map results...
}
\end{lstlisting}

\subsection{MongoDB Aggregation Pipeline}
\begin{lstlisting}[style=java, caption=MongoDB Aggregation Pipeline]
// Overdue loans via aggregation with lookups
public List<Document> getOverdueLoansWithDetails() {
  List<Bson> pipeline = Arrays.asList(
    Aggregates.match(Filters.and(
      Filters.eq("status", "ACTIVE"),
      Filters.lt("due_date", formatDate(LocalDate.now())))),
    Aggregates.lookup("students", "student_id", "student_id", "student_info"),
    Aggregates.lookup("books", "book_id", "book_id", "book_info")
  );
  return loans.aggregate(pipeline).into(new ArrayList<>());
}
\end{lstlisting}

\subsection{Oracle Transaction Management}
\begin{lstlisting}[style=java, caption=Oracle Transaction Management]
public boolean returnBook(int loanId) throws SQLException {
  Connection conn = connectionManager.getConnection();
  try {
    conn.setAutoCommit(false);
    loanDAO.updateLoanStatus(loanId, "RETURNED", LocalDate.now());
    Loan loan = loanDAO.getLoanById(loanId);
    bookDAO.incrementAvailableCopies(loan.getBookId());
    conn.commit();
    return true;
  } catch (SQLException e) {
    conn.rollback();
    throw e;
  } finally {
    conn.setAutoCommit(true);
  }
}
\end{lstlisting}

\subsection{MongoDB Atomic Operations}
\begin{lstlisting}[style=java, caption=MongoDB Atomic Operations]
@Override
public boolean returnLoan(int loanId) {
  Document existingLoan = loans.find(Filters.eq("loan_id", loanId)).first();
  if (existingLoan == null || "RETURNED".equals(existingLoan.getString("status"))) {
    throw new IllegalStateException("Loan not found or already returned");
  }
  Document update = new Document("status", "RETURNED")
      .append("return_date", formatDate(LocalDate.now()));
  boolean updated = loans.updateOne(
      Filters.and(
        Filters.eq("loan_id", loanId),
        Filters.ne("status", "RETURNED")),
      new Document("$set", update)).getModifiedCount() > 0;
  if (updated) {
    Loan loan = getLoanById(loanId);
    if (loan != null) {
      books.updateOne(
        Filters.eq("book_id", loan.getBookId()),
        Updates.inc("available_copies", 1));
    }
  }
  return updated;
}
\end{lstlisting}

\subsection{Maven Dual-Backend Configuration}
\begin{lstlisting}[style=java, caption=Maven dependencies and packaging]
<dependencies>
  <dependency>
    <groupId>com.oracle.database.jdbc</groupId>
    <artifactId>ojdbc8</artifactId>
    <version>21.7.0.0</version>
  </dependency>
  <dependency>
    <groupId>org.mongodb</groupId>
    <artifactId>mongodb-driver-sync</artifactId>
    <version>4.11.1</version>
  </dependency>
  <dependency>
    <groupId>com.formdev</groupId>
    <artifactId>flatlaf</artifactId>
    <version>3.2.5</version>
  </dependency>
</dependencies>

<!-- Launch4j executables with backend flags -->
<plugin>
  <groupId>com.akathist.maven.plugins.launch4j</groupId>
  <artifactId>launch4j-maven-plugin</artifactId>
  <version>2.1.2</version>
  <executions>
    <execution>
      <id>oracle-exe</id>
      <configuration>
        <outfile>${project.build.directory}/library_oracle.exe</outfile>
        <cmdLine>--backend=oracle</cmdLine>
      </configuration>
    </execution>
    <execution>
      <id>mongo-exe</id>
      <configuration>
        <outfile>${project.build.directory}/library_mongo.exe</outfile>
        <cmdLine>--backend=mongo</cmdLine>
      </configuration>
    </execution>
  </executions>
</plugin>
\end{lstlisting}

\subsection{Oracle Schema Synchronization Snippet}
\begin{lstlisting}[style=sql, caption=Oracle schema and sample data]
-- Sample rows aligned to Mongo seed
INSERT INTO Students (student_id, name, email) VALUES (1001, 'John Smith', 'john.smith@email.com');
INSERT INTO Books (book_id, title, author, isbn, category, publication_year, available_copies, total_copies)
VALUES (2001, 'Database Systems', 'Silberschatz, Korth, Sudarshan', '9780078022159', 'Databases', 2020, 2, 5);
INSERT INTO Loans (loan_id, student_id, book_id, loan_date, due_date, status, renewal_count)
VALUES (3001, 1001, 2001, DATE '2025-08-01', DATE '2025-08-15', 'ACTIVE', 0);
INSERT INTO Fines (fine_id, student_id, loan_id, fine_amount, payment_status)
VALUES (4001, 1001, 3001, 12.50, 'UNPAID');
\end{lstlisting}

\subsection{Swing Prototype: Borrow/Return Flows}
\begin{lstlisting}[style=java, caption=Borrow and return in Swing prototype]
private void borrowBook() {
  Student student = (Student) studentCombo.getSelectedItem();
  Book book = (Book) bookCombo.getSelectedItem();
  if (book.availableCopies > 0) {
    book.availableCopies--;
    loans.add(new Loan(loans.size() + 1, student.id, book.id,
                       student.name, book.title, "Active"));
    statusArea.setText("Book '" + book.title + "' borrowed by " + student.name);
  } else {
    statusArea.setText("Error: No copies of '" + book.title + "' available");
  }
}

private void returnBook() {
  Student student = (Student) studentCombo.getSelectedItem();
  Book book = (Book) bookCombo.getSelectedItem();
  for (Loan loan : loans) {
    if (loan.studentId == student.id && loan.bookId == book.id &&
        loan.status.equals("Active")) {
      loan.status = "Returned";
      book.availableCopies++;
      fines.add(new Fine(fines.size() + 1, student.id, student.name, 5.0, "Unpaid"));
      statusArea.setText("Book '" + book.title + "' returned by " + student.name +
                         ". Fine of $5.00 added for late return.");
      return;
    }
  }
  statusArea.setText("Error: No active loan found for this student and book");
}
\end{lstlisting}

\subsection{Build and Run Commands}
\begin{lstlisting}[style=java, caption=Build and run commands]
mvn clean package
java -jar target/library-database-system-1.0.0.jar

mvn dependency:copy-dependencies -DoutputDirectory=lib
java -cp "target/classes;lib/*" com.library.LibraryApp
\end{lstlisting}

\subsection{Oracle Connectivity Diagnostics}
\begin{lstlisting}[style=java, caption=Connectivity log excerpt]
ERROR:
ORA-01017: invalid username/password; logon denied

ERROR:
ORA-01005: null password given; logon denied
\end{lstlisting}

\section{References}

\begin{thebibliography}{15}

\bibitem{silberschatz2019}
Silberschatz, A., Galvin, P. B., \& Gagne, G. (2019). \textit{Database System Concepts} (7th ed.). McGraw-Hill Education.

\bibitem{chodorow2010}
Chodorow, K., \& Dirolf, M. (2010). \textit{MongoDB: The Definitive Guide}. O'Reilly Media.

\bibitem{fowler2002}
Fowler, M. (2002). \textit{Patterns of Enterprise Application Architecture}. Addison-Wesley Professional.

\bibitem{oracle2023}
Oracle Corporation. (2023). \textit{Oracle Database 21c Documentation}. Retrieved from https://docs.oracle.com/en/database/oracle/oracle-database/21/

\bibitem{mongodb2023}
MongoDB Inc. (2023). \textit{MongoDB Manual}. Retrieved from https://docs.mongodb.com/manual/

\bibitem{gamma1994}
Gamma, E., Helm, R., Johnson, R., \& Vlissides, J. (1994). \textit{Design Patterns: Elements of Reusable Object-Oriented Software}. Addison-Wesley Professional.

\bibitem{martin2017}
Martin, R. C. (2017). \textit{Clean Architecture: A Craftsman's Guide to Software Structure and Design}. Prentice Hall.

\bibitem{hohpe2003}
Hohpe, G., \& Woolf, B. (2003). \textit{Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions}. Addison-Wesley Professional.

\bibitem{evans2003}
Evans, E. (2003). \textit{Domain-Driven Design: Tackling Complexity in the Heart of Software}. Addison-Wesley Professional.

\bibitem{richardson2018}
Richardson, C. (2018). \textit{Microservices Patterns: With Examples in Java}. Manning Publications.

\bibitem{kleppmann2017}
Kleppmann, M. (2017). \textit{Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems}. O'Reilly Media.

\bibitem{redmond2012}
Redmond, E., \& Wilson, J. R. (2012). \textit{Seven Databases in Seven Weeks: A Guide to Modern Databases and the NoSQL Movement}. Pragmatic Bookshelf.

\bibitem{sadalage2012}
Sadalage, P. J., \& Fowler, M. (2012). \textit{NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence}. Addison-Wesley Professional.

\bibitem{oracle2023jdbc}
Oracle Corporation. (2023). \textit{JDBC Developer's Guide and Reference}. Retrieved from https://docs.oracle.com/en/database/oracle/oracle-database/21/jjdbc/

\bibitem{mongodb2023java}
MongoDB Inc. (2023). \textit{MongoDB Java Driver Documentation}. Retrieved from https://mongodb.github.io/mongo-java-driver/

\end{thebibliography}

\end{document}
